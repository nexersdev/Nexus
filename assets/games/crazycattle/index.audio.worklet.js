class t{constructor(t,s,i){this.buffer=t,this.avail=s,this.threads=i,this.rpos=0,this.wpos=0}data_left(){return this.threads?Atomics.load(this.avail,0):this.avail}space_left(){return this.buffer.length-this.data_left()}read(t){const s=this.buffer.length;let i=0,e=t.length;if(this.rpos+e>s){const r=s-this.rpos;t.set(this.buffer.subarray(this.rpos,s)),i=r,e-=r,this.rpos=0}e&&t.set(this.buffer.subarray(this.rpos,this.rpos+e),i),this.rpos+=e,this.threads?(Atomics.add(this.avail,0,-t.length),Atomics.notify(this.avail,0)):this.avail-=t.length}write(t){const s=t.length,i=this.buffer.length-this.wpos;if(i>=s)this.buffer.set(t,this.wpos),this.wpos+=s,i===s&&(this.wpos=0);else{const s=t.subarray(0,i),e=t.subarray(i);this.buffer.set(s,this.wpos),this.buffer.set(e),this.wpos=e.length}this.threads?(Atomics.add(this.avail,0,s),Atomics.notify(this.avail,0)):this.avail+=s}}class s extends AudioWorkletProcessor{constructor(){super(),this.threads=!1,this.running=!0,this.lock=null,this.notifier=null,this.output=null,this.output_buffer=new Float32Array,this.input=null,this.input_buffer=new Float32Array,this.port.onmessage=t=>{const s=t.data.cmd,i=t.data.data;this.parse_message(s,i)}}process_notify(){this.notifier&&(Atomics.add(this.notifier,0,1),Atomics.notify(this.notifier,0))}parse_message(s,i){if("start"===s&&i){const s=i[0];let e=0;this.threads=!0,this.lock=s.subarray(e,++e),this.notifier=s.subarray(e,++e);const r=s.subarray(e,++e),h=s.subarray(e,++e);this.input=new t(i[1],r,!0),this.output=new t(i[2],h,!0)}else"stop"===s?(this.running=!1,this.output=null,this.input=null,this.lock=null,this.notifier=null):"start_nothreads"===s?this.output=new t(i[0],i[0].length,!1):"chunk"===s&&this.output.write(i)}static array_has_data(t){return t.length&&t[0].length&&t[0][0].length}process(t,i,e){if(!this.running)return!1;if(null===this.output)return!0;if(s.array_has_data(t)){const i=t[0],e=i[0].length*i.length;this.input_buffer.length!==e&&(this.input_buffer=new Float32Array(e)),this.threads?this.input.space_left()>=e&&(s.write_input(this.input_buffer,i),this.input.write(this.input_buffer)):(s.write_input(this.input_buffer,i),this.port.postMessage({cmd:"input",data:this.input_buffer}))}if(s.array_has_data(i)){const t=i[0],e=t[0].length*t.length;this.output_buffer.length!==e&&(this.output_buffer=new Float32Array(e)),this.output.data_left()>=e&&(this.output.read(this.output_buffer),s.write_output(t,this.output_buffer),this.threads||this.port.postMessage({cmd:"read",data:e}))}return this.process_notify(),!0}static write_output(t,s){const i=t.length;for(let e=0;e<i;e++)for(let r=0;r<t[e].length;r++)t[e][r]=s[r*i+e]}static write_input(t,s){const i=s.length;for(let e=0;e<i;e++)for(let r=0;r<s[e].length;r++)t[r*i+e]=s[e][r]}}registerProcessor("godot-processor",s);